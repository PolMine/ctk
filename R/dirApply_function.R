#' apply a function to files in a directory
#' 
#' The function (f) will be applied to the files in a directory (in a lapply/sapply/vapply-style).
#' 
#' Function f passes in a function that will be applied to the individual files
#' in the source directory (sourceDir). The function needs to conform to a
#' standardized format, parameters required are "filename" (character),
#' "sourceDir" (character), "targetDir" (character) and "param" (list).
#' 
#' The function f can be applied in a multicore mode. If progress is FALSE, then
#' mclapply will be used. If progress is TRUE, that child processes will be 
#' generated by forking. Take care - if a call of this kind to dirApply is 
#' interrupted prematurely, the child processes may continue to be working.
#' Child processes that are left over can be detected with
#' parallel:::selectChildren and collected with parallel::mccollect().
#' 
#' To be able to get progress information, dummy files will be written to a
#' temporary directory. These logfiles are removed before and after the actual
#' parallel processing. In case of zombie child processes from an earlier interrupted
#' run, the counting may be utterly flawed.
#' 
#' @param f function that will be applied to all files in sourceDir 
#' @param sourceDir the source directory
#' @param targetDir target directory where the processed files will be saved
#' @param pattern pattern (can be a regex) that will be used by list.files as 'pattern'-argument
#' @param mc logical, whether to use multicore/parallel processing
#' @param progress logical, whether to show progress information
#' @param verbose logical, whether to be verbose
#' @param sample defults to FALSE, if TRUE, a numeric indicating a number of random files to process
#' @param filenames character vector with filenames to be used, if not all files in sourceDir are to processed
#' @param continue work only on those files not yet present in target dir
#' @param failsafe whether to be robust and catch errors
#' @param param a list with parameters to be passed to the function f
#' @export dirApply
#' @rdname dirApply
#' @name dirApply
#' @import parallel
dirApply <- function(
  f, sourceDir, targetDir=NULL,
  pattern=NULL, mc=FALSE, progress=TRUE, verbose=FALSE,
  sample=FALSE, filenames=NULL, continue=FALSE, failsafe=FALSE,
  param=list()
  ){
  if (is.null(filenames)) filenames <- list.files(sourceDir, pattern)
  if (length(filenames) == 0) stop("no files in sourceDir")
  if (continue == TRUE){
    if ( verbose == TRUE ) message ("... getting files not yet present in targetDir")
    filesTargetDir <- list.files(targetDir)
    filesTargetDirChomp <- gsub("^(.*)\\..*$", "\\1", filesTargetDir)
    filesSourceDirChomp <- gsub("^(.*)\\..*$", "\\1", filenames)
    filesToGo <- filenames[!filesSourceDirChomp %in% filesTargetDirChomp]
    if (verbose == TRUE){
      message("files in sourceDir -> ", length(filenames))
      message("files in targetDir -> ", length(filesTargetDir))
      message("skipping files -> ", length(filenames) - length(filesToGo))
    }
    filenames <- filesToGo
  }
  if (sample != FALSE) filenames <- sample(filenames, size=sample)
  
  if (mc == FALSE) {
    if (progress == TRUE) verbose <- FALSE
    startTime <- Sys.time()
    retval <- lapply(c(1:length(filenames)), function(i){
      if (verbose == TRUE) message("... processing ", filenames[i])
      if (progress == TRUE) .progressBar(i, length(filenames), showShare=TRUE, startTime=startTime)
      if (failsafe == FALSE) {
        toReturn <- f(filename=filenames[i], sourceDir=sourceDir, targetDir=targetDir, verbose=verbose, param=c(fileNo=i, filesTotal=length(filenames), param))  
      } else {
        toReturn <- try(f(filename=filenames[i], sourceDir=sourceDir, targetDir=targetDir, verbose=verbose, param=c(fileNo=i, filesTotal=length(filenames), param)))
      }
      toReturn
    })
    if (unique(lapply(retval, function(x) class(x)[1])) == "difftime"){
      class(retval) <- "timePerFile"
    }
    names(retval) <- filenames
    return(retval)
  } else if (mc == TRUE || is.numeric(mc)){
    if (is.numeric(mc) == TRUE){
      noCores <- mc
      if (verbose == TRUE) message("... using ", noCores, " cores")
    } else {
      noCores <- 3  
      if (verbose == TRUE) message("... number of cores not provided explicitly, using ", noCores, " cores")
    }
    if (progress == FALSE){
      retval <- mclapply(
        c(1:length(filenames)),
        function(i) f(
          filenames[i], sourceDir=sourceDir, targetDir=targetDir,
          verbose=verbose, param=c(fileNo=i, filesTotal=length(filenames), param)
          ),
        mc.cores=noCores
        )  
    } else if (progress == TRUE){
      breaksRaw <- unlist(lapply(c(1:noCores), function(x) rep(x, times=trunc(length(filenames) / noCores))))
      breaks <- c(breaksRaw, rep(noCores, times=length(filenames)-length(breaksRaw)))
      fileChunks <- split(filenames, breaks)
      dummyDir <- tempdir()
      filesRemoved <- file.remove(list.files(dummyDir, full.names=T, pattern="\\.multicore", include.dirs=FALSE))
      noFilesRemoved <- length(filesRemoved)
      if (noFilesRemoved > 0 && verbose == TRUE){
        message ("... logfiles were still present im tempdir, ", length(filesRemoved), " files removed")  
      }
      fWrapped <- function(filename, sourceDir, targetDir, verbose, param){
        cat("", file=file.path(dummyDir, paste(filename, "multicore", sep=".")))
        f(filename, sourceDir=sourceDir, targetDir=targetDir, verbose=verbose, param=param)
      }
      if (length(parallel:::children()) > 0){
        warning("there have been zombie processes collected with mccollect()")
        graveyard <- mccollect()
      }
      threadNames <- paste("thread", c(1:noCores), sep="")
      startTime <- Sys.time()
      for (i in c(1:noCores)){
        assign(
          threadNames[i],
          mcparallel(
            lapply(
              fileChunks[[i]],
              function(filename) {
                fWrapped(filename, sourceDir=sourceDir, targetDir=targetDir, verbose=FALSE, param=c(param, thread=threadNames[i]))
              }
            )),
          envir=environment())
        }
      while (length(parallel:::selectChildren()) < noCores){
        filesTargetDir <- list.files(path=dummyDir, pattern="\\.multicore")
        .progressBar(length(filesTargetDir), length(filenames), showShare=TRUE, startTime=startTime)
        Sys.sleep(1)
      }
      retval <- parallel::mccollect(
        jobs=lapply(threadNames, function(x) get(x, envir=environment())),
        wait=TRUE
        )
      filesTargetDir <- list.files(path=dummyDir, pattern="\\.multicore")
      .progressBar(length(filesTargetDir), length(filenames), showShare=TRUE, startTime=startTime)
      dummy <- file.remove(list.files(dummyDir, full.names=T, pattern="\\.multicore", include.dirs=FALSE))
      retval <- unlist(retval, recursive = FALSE)
      if (unique(lapply(retval, function(x) class(x)[1])) == "difftime"){
        class(retval) <- "timePerFile"
      }
      names(retval) <- filenames
      return(retval)
    }
  }
}
