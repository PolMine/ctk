% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dirApply_function.R
\name{dirApply}
\alias{dirApply}
\title{apply a function to files in a directory}
\usage{
dirApply(f, sourceDir, targetDir = NULL, pattern = NULL, mc = FALSE,
  progress = TRUE, verbose = FALSE, sample = FALSE, filenames = NULL,
  continue = FALSE, failsafe = FALSE, param = list())
}
\arguments{
\item{f}{function that will be applied to all files in sourceDir}

\item{sourceDir}{the source directory}

\item{targetDir}{target directory where the processed files will be saved}

\item{pattern}{pattern (can be a regex) that will be used by list.files as 'pattern'-argument}

\item{mc}{logical, whether to use multicore/parallel processing}

\item{progress}{logical, whether to show progress information}

\item{verbose}{logical, whether to be verbose}

\item{sample}{defults to FALSE, if TRUE, a numeric indicating a number of random files to process}

\item{filenames}{character vector with filenames to be used, if not all files in sourceDir are to processed}

\item{continue}{work only on those files not yet present in target dir}

\item{failsafe}{whether to be robust and catch errors}

\item{param}{a list with parameters to be passed to the function f}
}
\description{
The function (f) will be applied to the files in a directory (in a lapply/sapply/vapply-style).
}
\details{
Function f passes in a function that will be applied to the individual files
in the source directory (sourceDir). The function needs to conform to a
standardized format, parameters required are "filename" (character),
"sourceDir" (character), "targetDir" (character) and "param" (list).

The function f can be applied in a multicore mode. If progress is FALSE, then
mclapply will be used. If progress is TRUE, that child processes will be 
generated by forking. Take care - if a call of this kind to dirApply is 
interrupted prematurely, the child processes may continue to be working.
Child processes that are left over can be detected with
parallel:::selectChildren and collected with parallel::mccollect().

To be able to get progress information, dummy files will be written to a
temporary directory. These logfiles are removed before and after the actual
parallel processing. In case of zombie child processes from an earlier interrupted
run, the counting may be utterly flawed.
}
